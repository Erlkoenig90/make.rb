# @title Using make.rb

# Using make.rb
## Installing
Obtain the source via git, build the gem, and install it:

	git clone git://minecraft.niklas.2g2s.de:50002/make.rb
	gem build make.rb
	gem install make.rb

## Configuring make.rb for a project
Similar to other build systems, make.rb requires you to write a file containing declarations about when to run what
builders to run. This file is usually called 'make.rb', and is a normal ruby script which includes the make.rb
library, instantiates various objects, defines connections between them and finally has make.rb perform the
actual build process. The most important classes here are the {MakeRb::Builder Builder} classes, which identify
external programs (builders) to be run by make.rb, and the {MakeRb::Resource Resource} classes, which identify
data sets (usually files, but could also be database entries etc.) that are read or generated by the builders.
Each Builder instance is assigned an array of resources to be read (sources) and an array of resources to be
generated (targets).

make.rb includes a 'convenience API' which simplifies building the graph of builders and resources for
most use cases. What follows is an explanation by example about how to use this API.

### make.rb convenience API
The basic layout for a make.rb project configuration file is:

	require 'make.rb'	# Load the make.rb library
	
	include MakeRb		# These are not strictly required, but result in shorter code
	include MakeRbCCxx
	include MakeRbBinary
	include MakeRbExt
	
	# Initialize the build system. The exit command is used to give this process a meaningful exit code
	exit BuildMgr.run {	
		# Declarations for the project go here
	} # After this block returns, the BuildMgr starts the build process.
An example for the declarations would be:

	rule "cc", [CFile], [CObjFile], host + {language: MakeRbLang::C}, buildMgr.typeKeys[:host][:toolchain].compiler
	rule "ld", [], [Executable], host + {language: MakeRbLang::C}, buildMgr.typeKeys[:host][:toolchain].linker
	
	ofiles = dep "cc", [["main.c"]], [["main.o"]]
	dep "ld", ofiles, [["test"]]

This compiles a C source file "main.c" into an object file "main.o" which is then linked as an executable "test". The
first two lines use the "{MakeRbConv#rule rule}" method to define two rules, called "cc" and "ld". A rule combines various settings for
for running a builder into a single name. The main aspect is to define the builder class and the classes for the sources
and targets. The rule's name can subsequently be used by the "{MakeRbConv#dep dep}" method which makes instances of
the defined resource classes and the builder class and applies the settings defined by the rule to them.

The first argument to "rule" is the new rule's name. The second is an array of ruby classes that represent the sources
for this rule, the third argument is the same for the targets. The fourth one is an array of arbitrary order for specifying
the builder class and other settings.

The above example specifies a C source file as the sole source for the builder and a (C) object file as it's sole target.
The build class is here specified by "buildMgr.typeKeys[:host][:toolchain].compiler". This selects the compiler for
the currently (via command line arguments) selected host platform (i.e. the platform which the final program shall
run on). The next example will show how to shorten this. The "host + `{language: MakeRbLang::C}`" selects predefined
settings from a matrix (TODO link) built by make.rb which will then be used by the builder. The "host" method selects some
settings defined for the selected host platform (see [command line arguments](#commandline)), and the hash merged in via "+"
selects the programming language. Some things (like libraries) might be available but work differently for multiple
languages, so specifying the language is required. You will see more about this later.

The second rule called "ld" specifies no source classes. This is because later an already existing resource (generated
by the previous "dep" command, the compiler) is passed in, so no new resource has to be generated here, except from the
target.

What follows are two calls to "dep", which reference the respective rules by name and receive the constructor arguments
for the resource instances. The second argument is an array of arrays of arguments passed to the constructor of a
resource. The order must correspondent to the order of the class-Array in the "dep" call. The third argument is the
same for the target resources. The "dep" call returns an array of the generated target resource instances, which are
here saved into the "ofiles" variable, which is subsequently passed into the next "dep" call, instead of arguments
to resource constructors.

This is a shorter version of the above example:
 
	rule "cc", [CFile], [CObjFile], host + {language: MakeRbLang::C}, :compiler
	rule "ld", [], [Executable], host + {language: MakeRbLang::C}, :linker
	
	ofiles = dep "cc", "main.c"
	dep "ld", ofiles, "test"

The long call to get the compiler class is gone, and replaced by a keyword, which will be sent to "buildMgr.typeKeys[:host][:toolchain]"
to get the actual compiler class, while "host" part will be replaced by what has been specified before. The brackets
for the arguments of "dep" are left out - this can be done when the arrays have only one argument. The "main.o"
filename is also omitted, and will be automatically generated from the "main.c" filename by the {MakeRbCCxx::CObjFile.auto}
method. This way you can rename "main" and only need to adjust the name at one place in the make.rb script.

The "rule" command also has an integrated way of declaring libraries:

	loadExt "gtk"

	rule "cc", [CFile], [CObjFile], host + {language: MakeRbLang::C}, Gtk3.latest, :compiler
	rule "ld", [], [Executable], host + {language: MakeRbLang::C}, Gtk3.latest, :linker

This will compile & link the program with the latest Gtk3 library available for the selected platform. Other
possibilities are:
	
	rule "cc", [CFile], [CObjFile], host + {language: MakeRbLang::C}, Gtk3 >= [3,4,4], Pango.latest, :compiler
	rule "cc", [CFile], [CObjFile], host + {language: MakeRbLang::C}, Gtk3 < [3,4,5], :compiler
	rule "cc", [CFile], [CObjFile], host + {language: MakeRbLang::C}, Gtk3.where {|ver| ver >= [3,4,0] && ver < [3,5,0] }, :compiler
	
An array like [3,4,4] obviously refers to version 3.4.4, the usage should be self-explanatory.

<a name="commandline"></a>
## Invocation

Three platforms can be defined when starting a make.rb script. These are:

* build: The platform make.rb is running on. Programs compiled for this platform should be executable by make.rb.
   This can be used by custom make.rb scripts to run preprocessing tasks.
* host: The platform the compiled program will run on. This is the most important one.
* target: The platform the compiled program will produce code for; only useful for compilers.
 
These three platforms can be specified by the respective --build=<name>, --host=<name>, --target=<name> arguments to
the make.rb script. All of them default to 'native', which means the platform make.rb is running on. For supported
platform names, see the source of {MakeRb::Platform.platforms}. An example would be:

	~ $ ruby make.rb --host=stm32f4

make.rb also allows modifying the specified platform
directly via the command line for easy adjustment of some settings. See this example:

	~ $ ruby make.rb --host=stm32f4,prefix:/opt/gcc-arm-embedded/bin/arm-none-eabi-,cFlags=-Wall\\,-O2,tc:gcc

The prefix will be prepended to all compiler and linker calls. This allows to have multiple compilers for different
targets to be installed. The argument "tc" defines the toolchain to be used. The arguments cFlags, cxxFlags,
ldFlags are used to specify flags to the C compiler, the C++ compiler and the linker, respectively. Note that these
have to be compatible to the selected toolchain. If no toolchain has been specified, the default one for the selected
platform will be used.

Other options are:

* --jobs, -j Number of jobs to run simultaneously, 0 for infinite (default: 1)
* --builddir Store generated files in this directory (default: build)
* --keep-going Don't abort on error, but run as many tasks as possible 

See also the output of "ruby make.rb --help".